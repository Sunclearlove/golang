### GoLang



#### 一、变量的数据类型

##### 		1.  基本数据类型 

```go
一、数值型： 

	1. 整数类型	(int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,byte)
		用于存放整数值，比如0，-1, 2345等等

	2. 浮点类型(float32, float64)

二、字符型(没有专门的字符型，使用byte来保存单个字母字符)
	var cl byte = '你'
	1. 字符使用细节
	1.1 字符常量用单引号('')括起来的单个字符,例如: var cl byte = 'a'
	1.2 Go中允许使用转义字符'\'来将其后的字符串转变为特殊字符型常量. 
		例如: var c3 char = '\n' '\n'表示换行符
	1.3 Go语言的字符使用UTF-8编码
	1.4 在go中,字符的本质是一个整数.直接输出时,是该字符对应的UTF-8编码的码值
	1.5 可以直接给某个变量赋一个数字, 然后按格式化输出时%c, 会输出的该数字对应的unicode字符
	1.6 字符类型是可以进行运算的,相当于一个整数,因为它对应有Unicode码

三、布尔型(bool) bool类型的数据只允许取值true和false
	1. bool类型占1个字节
	2. boolean类型适于逻辑运算, 用于流程控制
	

四、字符串类型(string)[官方将string归属到基本数据类型]
	1. go语言的字符串的字节使用UTF-8编码标识Unicode文本,这样不会有中文乱码的问题
	2. 字符串一旦赋值了, 字符串就不能修改,在go字符串是不可变得
	3. 字符串的两种表现形式
		(3.1) 双引号.会识别转义字符
		(3.2) 反引号,以字符串的原生形式输出,包括换行和特殊字符,可以实现防止攻击,输出源代码等效果

语法: unsafe.Sizeof() 获取值得大小字节
```
整数的类型

| 类型 | 有无符号 |           占用存储空间           |                     表述范围                      | 备注                        |
| :--: | :------: | :------------------------------: | :-----------------------------------------------: | --------------------------- |
| int  |    有    | 32位系统四个字节/64位系统8个字节 | -2的31次方~2的31次方 - 1/-2的31次方~2的31次方 - 1 |                             |
| uint |    无    | 32位系统四个字节/64位系统8个字节 |            0~2的32次方-1/0~2的64次方-1            |                             |
| rune |    有    |           与int32一样            |              -2的31次方~ 2的31次方-1              | 等价int32,表示一个unicode码 |
| byte |    无    |           与uint8等价            |                      0 ~ 255                      | 当要存储字符时选用byte      |

基本数据类型默认值

| 数据类型 | 默认值 |
| -------- | ------ |
| 整数     | 0      |
| 浮点型   | 0      |
| 字符串   | " "    |
| 布尔类型 | false  |



##### 	2. 派生/复杂数据类型

```
一、指针(Pointer)
二、数组
三、结构体(struct)
四、管道(channel)
五、函数(也是一种类型)
六、切片(slice)
七、接口(interface)
八、map
```



#### 二、基本数据类型的相互转换

##### 	2.1、基本介绍：

​		go在不同的类型的变量之间赋值时需要显式转换.也就是说golang中数据类型不能自动转换

##### 	2.2、基本语法:

​		表达式 T(v) 将值 v 转换为类型 T

​		`T` : 就是数据类型， 比如int32. int64， float32等等

​		`v` : 就是需要转换的变量

##### 	2.3、案例演示:

```go
package main

import("fmt")

// 演示golang中的基本数据类型的转换
func main () {
    var i int32 = 100
    var n1 float32 = float32(i)
    var n2 int8 = int8(i)
    var n3 int64 = int64(i)
    
    fmt.Printf("i=%v n1=%v n2=%v n3=%v", i, n1, n2, n3)
}
```

##### 	2.4 基本数据类型互相转换的注意事项

​		(1) 数据类型的转换可以从 表示范围小 --> 表示范围大, 也可以 范围大--> 范围小, 

​		(2) 被转换的是变量存储的数据, 变量本身的数据类型并没有变化

​		(3) 在转换中, 比如将 int64 转成 int8 [-128 ~ 127], 编译不会报错, 只是转换的结果是按溢出处理. 和我们希望看到的结果不一样的



#### 三、基本数据类型和string的转换

##### 	3.1 基本介绍

​			在程序开发中, 我们经常需要将基本数据类型转成string类型, 或者将string类型  			转成基本数据类型

##### 	3.2 基本类型转string类型

​		**方式1**: fmt.Sprintf("%参数", 表达式) [**个人习惯, 灵活**]

​			函数的介绍:

​				func Sprintf

```
func Sprintf(format string, a ...interface{}) string
```

​			**Sprintf根据format参数生成格式化的字符串并返回该字符串。**

​			(1) 参数需要和表达式的数据类型相匹配

​			(2) fmt.Sprintf()... 会返回转换后的字符串

​			(3) 案例演示

​			

```go
package main

import "fmt"

func main() {
	var num1 int = 99
	var num2 float64 = 23.456
	var b bool = true
	var myChar byte = 'h'
	var str string

	// fmt.Sprintf方法
	// %T相应值的类型的Go语法表示  %v相应值的默认格式 %q单引号围绕的字符字面值，由Go语法安全地转义
	str = fmt.Sprintf("%d", num1) // 数值转string类型
	fmt.Printf("%T str=%q\n",str, str)

	str = fmt.Sprintf("%f", num2) // 浮点型转string类型
	fmt.Printf("%T str=%q\n",str, str)

	str = fmt.Sprintf("%t", b) // bool转string类型
	fmt.Printf(" str  type %T str=%q\n",str, str)

	str = fmt.Sprintf("%c", myChar) // 字符型转string类型
	fmt.Printf(" str  type %T str=%q\n",str, str)
}
```

​		

​		**方式2**: 使用 strconv 包的函数

​			`func.FormatBool(b nool) string`

```go
	var num3 int = 91
	var num4 float64 = 23.456
	var b2 bool = true
	str = strconv.FormatInt(int64(num3), 10)
	fmt.Printf(" str  type %T str=%q\n",str, str)
	// strconv.FormatFloat(num4, 'f', 10, 64) 说明: 'f' 格式, 10: 表示小数点保留10位. 64: 表示这个小数是float64
	str = strconv.FormatFloat(num4, 'f', 10, 64)
	fmt.Printf(" str  type %T str=%q\n",str, str)

	str = strconv.FormatBool(b2)
	fmt.Printf("str type %T str=%q\n", str, str)




	// strconv包中有一个函数Itoa
	var num5 int64 = 4567
	str = strconv.Itoa(int(num5))
	fmt.Printf("str type %T str=%q\n", str, str)


```



##### 3.3 string类型转基本数据类型

​	(1) 使用strconv包的函数

​		`func.ParseBool(str string)(value bool, err, error)`

​		`func.ParseFloat(s string, bitSize int)(f float64, err, error)`

​		`func.ParseInt(s string, base int bitSize int)(i int64, err, error)`

​		`func.ParseUint(s string, b int bitSize int)(n uint64, err, error)`

​	(2) 案例演示

```
	var str string = "true" // string 转bool
	var b bool
	// strconv.ParseBool(str) 函数回返回两个值 (value bool, err error)
	// 因此我只想获取到value bool, 不想获取到err 所以使用 _ 忽略
	b, _ = strconv.ParseBool(str)
	fmt.Printf("b的类型是 %T 值是 b=%v\n", b, b)

	var str2 string = "12312234" // string 转int整数类型
	var n1 int64
	n1, _ = strconv.ParseInt(str2, 10, 64)
	fmt.Printf("n1 type %T n1=%v\n", n1, n1)

	var str3 string = "123.456" //string 转 浮点型
	var f1 float64
	f1, _ = strconv.ParseFloat(str3, 64)
	fmt.Printf("f1 type %T f1=%v\n", f1, f1)
```

​	**note** : 因为返回的是int64或者是float64, 如希望要得到int32, float32等需要如下处理;

​	`va num5 int32  `

​	`num5 = int32(num)` 

​	(3) 注意事项

​		在讲strng类型转换成 基本数据类型时, 要确保string类型能够转成有效的数据, 比如我们可以把"123",转成一		个整数, 但不能把"hello"转成一个整数, 如果这样做, 在Golang直接将其转为0

​		其他类型也是一样的道理  float => 0 bool => false

​		`var str string = "hello"`

​		`var num int64`

​		`num, _ = strconv.ParseInt(str, 10, 64)`

​		`fmt.Printf("num type = %T num value = %d \n", num. num)`



#### 四、Go语言占位符的使用

##### 	4.1 基本介绍:

​		golang的fmt包实现了格式化I/O函数, 类似C中的printf和scanf

```go
// 定义示例类型和变量
type Human struct {
    Name string
}

var people = Human{Name:"zhangsan"}
```

##### 		4.2 普通占位符

| 占位符 | 说明                           | 举例                  | 输出                        |
| ------ | ------------------------------ | --------------------- | --------------------------- |
| %v     | 相应值得默认格式               | Printf("%v", people)  | {zhangsan}                  |
| %+v    | 打印结构体时，会添加字段名     | Printf("%+v", people) | {Name:zhangsan}             |
| %#v    | 相应值的Go语法表示             | Printf("#v", people)  | main.Human{Name:"zhangsan"} |
| %T     | 相应值的类型的Go语法表示       | Printf("%T", people)  | main.Human                  |
| %%     | 字面上的百分号，并非值的占位符 | Printf("%%")          | %                           |

##### 		4.3 布尔占位符

| 占位符 | 说明            | 举列               | 输出 |
| ------ | --------------- | ------------------ | ---- |
| %t     | true 或 false。 | Printf("%t", true) | true |

##### 		4.4 整数占位符

| 占位符 | 说明                                       | 举例                 | 输出   |
| ------ | ------------------------------------------ | -------------------- | ------ |
| %b     | 二进制表示                                 | Printf("%b", 5)      | 101    |
| %c     | 相应Unicode码点所表示的字符                | Printf("%c", 0x4E2D) | 中     |
| %d     | 十进制表示                                 | Printf("%d", 0x12)   | 18     |
| %o     | 八进制表示                                 | Printf("%d", 10)     | 12     |
| %q     | 单引号围绕的字符字面值，由Go语法安全地转义 | Printf("%q", 0x4E2D) | '中'   |
| %x     | 十六进制表示，字母形式为小写 a-f           | Printf("%x", 13)     | d      |
| %X     | 十六进制表示，字母形式为大写 A-F           | Printf("%x", 13)     | D      |
| %U     | Unicode格式：U+1234，等同于 "U+%04X"       | Printf("%U", 0x4E2D) | U+4E2D |

##### 	4.5 浮点数和复数的组成部分 (实部和虚部)

| 占位符 | 说明                                              | 举例子                 | 输出         |
| ------ | ------------------------------------------------- | ---------------------- | ------------ |
| %b     | 无小数部分,指数为二的幂的科学计数法               |                        |              |
| %e     | 科学计数法, 例如 -1234.456+78                     | Printf("%e", 10.2)     | 1.020000e+01 |
| %E     | 科学计数法，例如 -1234.456E+78                    | Printf("%e", 10.2)     | 1.020000E+01 |
| %f     | 有小数点而无指数，例如 123.456                    | Printf("%f", 10.2)     | 10.200000    |
| %g     | 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0） | Printf("%g", 10.20)    | 10.2         |
| %G     | 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0） | Printf("%G", 10.20+2i) | (10.2+2i)    |

##### 	4.6 字符串与字节切片

| 占位符 | 说明                                   | 举例                           | 输出         |
| ------ | -------------------------------------- | ------------------------------ | ------------ |
| %s     | 输出字符串表示（string类型或[]byte)    | Printf("%s", []byte("Go语言")) | Go语言       |
| %q     | 双引号围绕的字符串，由Go语法安全地转义 | Printf("%q", "Go语言")         | "Go语言"     |
| %x     | 十六进制，小写字母，每字节两个字符     | Printf("%x", "golang")         | 676f6c616e67 |
| %X     | 十六进制，大写字母，每字节两个字符     | Printf("%X", "golang")         | 676F6C616E67 |

##### 	4.7 指针

| 占位符 | 说明                  | 举例                  | 输出     |
| ------ | --------------------- | --------------------- | -------- |
| %p     | 十六进制表示，前缀 0x | Printf("%p", &people) | 0x4f57f0 |



#### 五、指针

##### 	5.1 基本介绍

​	(1) 基本数据类型,变量存的就是值, 也叫值类型

​	(2) 获取变量的地址,用 & 比如:  var num int 获取num的地址: &num

​		案例 :

```go
	// 基本数据类型在内存布局
	var i int = 10
	// i 的地址是什么 , &i
	fmt.Println("i的地址=", &i) // 打印 0xc00000e098
```

​	(3) 指针类型,变量存的是一个地址, 这个地址指向的空间存的才是值 比如: var ptr* int = &num

​		案例 :

```go
	var i int = 10	
	// 1. ptr 是一个指针变量
	// 2. ptr 的类型 *int
	// 3. ptr 本身的值 &i
	var ptr *int = &i
	fmt.Printf("ptr=%v\n", ptr) // 打印 0xc00000e098
```

​	(4) 获取指针类型所指向的值, 使用: *, 比如: var *ptr int, 使用 *ptr获取ptr指向的值

​		案例 :

```go
var i int = 10	
// 1. ptr 是一个指针变量
// 2. ptr 的类型 *int
// 3. ptr 本身的值 &i
var ptr *int = &i
fmt.Printf("ptr=%v\n", *ptr) // 10
```

​	(5) 举例说明

![指针案例](E:\study\GOPROJECTS\笔记\指针案例.png)



​	(6) 案例演示

​		6.1. 写一个程序, 获取一个int变量 num 的地址, 并显示到终端

​			`var num int = 9`

​			`fmt.Printf("num address=%v\n", &num) ` // 输出地址

​		6.2. 讲 num 的地址赋给指针 ptr, 并通过 ptr 去修改 num 的值

​			`var num int = 9`

​			`var ptr *int`

​			`ptr = &num`

​			`*ptr = 10`  // 这里修改时, 会到num值的变化

​			`fmt.printIn("num=", num)`   `输出 10`



##### 	5.2 指针细节说明

​		(1) 值类型, 都有对应的指针类型, 形式为 *数据类型, 比如 int 的对应的指针就是 *int, float32 对应的指针类型		就是 *float32

​		(2) 值类型包括: 基本数据类型 int, float, bool, string. 数组和结构体struct



#### 六、值类型和引用类型

##### 	6.1 常见的值类型和引用类型

​		(1) 值类型: 基本数据类型int系列, float系列, bool, string, 数据和结构体struct

​		(2) 引用类型: 指针, slice切片, map, 管道chan, interface, 等都是引用类型



##### 	6.2 值类型和引用类型的使用特点

​		(1) 值类型: 变量直接存储值, 内存通常在栈中分配

​		![](E:\study\GOPROJECTS\笔记\微信图片_20220515185425.png)

​		(2) 引用类型: 变量存储的是一个地址, 这个地址对应的空间才是真正存储数据(值), 内存通常在 堆 上分配. 当			没有任何变量引用这个地址时,该地址对应的数据空间就成为一个垃圾, 由GC来回收

​			![](E:\study\GOPROJECTS\笔记\微信图片_20220515185439.png)

​		(3) 内存的栈区和堆区示意图

​				![](E:\study\GOPROJECTS\笔记\微信图片_20220515185445.png)





#### 七、标识符的命名规范

##### 	7.1 标识符基本介绍

​		(1) Golang 对各种变量, 方法等命名时使用的字符序列称为标识符

​		(2) 凡是自己可以起名字的地方都叫标识符

##### 	7.2 标识符的命名规则

​		(1) 由26个英文字母大小写, 0-9, _ 组成

​		(2) 数字不可以开头

​		(3) Golang中严格区分大小写

​		(4) 标识符不能包含空格

​		(5) 下划线 " " 本身在Go中是一个特殊的标识符. 称为 **空标识符**. 可以代表任何其他的标识符,但是他对应的值会		被忽略(比如: 忽略某个返回值). 所以仅能被作为占位符使用, 不能作为标识符使用.

​		(6) 不能以系统  **保留关键字** 作为标识符, 比如 break, if 等等....

##### 	7.3 标识符的命名规范

​		(1) 包名: 保持package的名字和目录保持一致,尽量采取有意义的包名, 简短, 有意义, 不要和标准库冲突

​		(2)  变量, 函数名, 常量名,: 采取驼峰法

​		(3) 如果变量名, 函数名, 常量名首字母大写, 则可以被其他的包访问; 如果首字母小写, 则只能在本包中使用(**注**: 		可以简单的理解成, 首字母大写是公有的, 首字母小写是私有的



#### 八、运算符

##### 		8.1 运算符

​		**介绍** : 算术运算符是对数值类型的变量进行运算的, 比如: 加减乘除.

##### 		8.2 算术运算符

| 运算符 |    运算    |    范例    | 结果  |
| :----: | :--------: | :--------: | :---: |
|   +    |    正号    |     +3     |   3   |
|   -    |    负号    |     -4     |   4   |
|   +    |     加     |   5 + 5    |  10   |
|   -    |     减     |   6 - 4    |   2   |
|   *    |     乘     |   3 * 4    |  12   |
|   /    |     除     |   5 / 5    |   1   |
|   %    | 取模(取余) |   7 % 5    |   2   |
|   ++   |    自增    | a = 2  a++ | a = 3 |
|   --   |    自减    | a = 2  a-- | a = 1 |

​		细节说明 : 

​		(1) 对于除号"/",它的整数除和小数除有区别, 整数除法, 只保留整数部分而舍弃小数部分.例如  **x:=19/5 等于3**

​		(2) 当对一个数取模时, 可以等价 a%b = a - a/b*b, 这样我们可以看到取模的一个本质运算

​		(3) Golang的自增自减只能当做一个独立的语言使用 b := a++ 或者 b:=a--

​		(4) Golang的 ++ 和 -- 只能写在变量的后面, 不能写在变量的前面 即: 只有 a++ a-- 

##### 		8.3 比较运算符(比较运算符)

​		介绍: (1) 关系运算符的结果是bool型, 也就是true 或者 false

​				  (2) 关系表达式经常用在if结构的条件中或循环结构中

| 运算符 |   运算   | 范例  | 结构  |
| :----: | :------: | :---: | :---: |
|   ==   |  相等于  | 4==3  | false |
|   !=   |  不等于  | 4 !=3 | true  |
|   <    |   小于   |  4<3  | false |
|   >    |   大于   |  4>3  | true  |
|   <=   | 小于等于 | 4<=3  | false |
|   >=   | 大于等于 | 4>=3  | true  |

##### 		8.4 逻辑运算符

​		介绍: 用于链接多个条件(一般来讲关系表达式) 最终的结果也是一个bool值

| 运算符 | 描述                                                         | 实例            |
| ------ | ------------------------------------------------------------ | --------------- |
| &&     | 逻辑 与 运算符. 两边都是true, 则操作数都是ture, 则为 true 否则为false | (A && B) false  |
| \|\|   | 逻辑 或 运算符. 如果两边的操作数有一个true 则为true 否则为 false | (A \|\| B) true |
| !      | 逻辑 非 运算符 如果条件为true 则逻辑为 fasle 否则为 true     | ! (A && B) true |

##### 		8.5 赋值运算符

​		介绍: 赋值运算符及时将某个运算后的值, 赋给指定的变量

| 运算符 |                      描述                      |             实例             |
| :----: | :--------------------------------------------: | :--------------------------: |
|   =    | 简单的赋值运算符, 将一个表达式的值赋给一个左值 | c = a  + b 表达式结果赋值给c |
|   +=   |                  相加后在赋值                  |    c +=a  等于 c = c + a     |
|   -=   |                  相减后再赋值                  |    c -=a  等于 c = c - a     |
|   *=   |                  相乘后再赋值                  |    c *=a  等于 c = c * a     |
|   /=   |                  相除后再赋值                  |    c /=a  等于 c = c / a     |
|   %=   |                  求余后再赋值                  |    c %=a  等于 c = c % a     |

##### 		8.6 位运算符

###### 	8.6.1 Golang有3个位运算

​	分别是  `按位与&` , `按位或|` , `按位异或^` 它们的运算规则是: 

​		`按位与&` : 两位全为 1, 结果为 1, 否则为 0

​		`按位或|` : 两位全为 1, 结果为 1, 否则为 0

​		`按位异或^` : 两位一个为0, 一个为1, 结果为 1 否则为0 

###### 	8.6.2 案例练习

​		比如 : 2 & 3 = ?           2 | 3 = ?       2 ^ 3 = ?

```
2 & 3
 -- 2的补码 0000 0010
 -- 3的补码 0000 0011
 2 & 3     0000 0010 => 2
 
 2 | 3
 -- 2的补码 0000 0010
 -- 3的补码 0000 0011
 2 | 3     0000 0011 => 3
 
  2 ^ 3
 -- 2的补码 0000 0010
 -- 3的补码 0000 0011
 2 ^ 3     0000 0001 => 1
 
 
 
 
```



​	(2) 位运算思考题

​	下面的表达式运算的结果是:

```
func main () {
	fmt.Println(2 & 3)
	fmt.Println(2 | 3)
	fmt.Println(13 & 7)
	fmt.Println(5 | 4)
	fmt.Println(-3 ^ 3)
}
```

​	

​	(3) 位运算符 和 移位运算符

​		golang中有两个移位置运算符

​		`>>`  `<<`移和左移运算规则 :

​		右移运算符: >> : 低位溢出, 符号位不变, 并用符号位补溢出的高位

​		左移运算符: << : 符号位不变, 低位补0

​		`a := 1 >> 2 // 0000 0001 = 0000 0000 = 0`

​		`c := 1 << 2 // 0000 0001 = 0000 0100 = 4`



| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 按位与运算符 "&" 是双目运算符. 其功能是参与运算的两数各对应的二进位相与 |
| \|     | 按位与运算符"\|" 是双目运算符. 其功能是参与运算的两数各对应的二进位相或运算规则是: 有一个为1, 结果为 1, 否则 为 0 |
| ^      | 按位异或运算符"^"是双目运算符. 其功能是参与运算的两数各对应的二进位相异或. 运算规则: 当二进位不同时, 结果为1,否则为0 |
| <<     | 左移运算符"<<"是双目运算符. 其功能是把"<<""左边的运算数的各二进位全部左移若干位, 高位丢弃,低位补0. 左移n位就是乘以2的n次方 |
| >>     | 右移运算符">>"是双目运算符. 其功能是把">>""左边的运算数的各二进位全部右移若干位,右移n位就是乘以2的n次方 |



##### 	8.7 其它运算符

| 运算符 |       描述       |           实例           |
| :----: | :--------------: | :----------------------: |
|   &    | 返回变量存储地址 | &a; 将给出变量的实际地址 |
|   *    |                  |    *a; 是一个指针变量    |

##### 8.8 原码, 反码, 补码

​	网上对原码, 反码, 补码的解释过于复杂, 我们这里精简几句

​	对于有符号的而言:

​		(1) 二进制的最高位是符号位: 0表示正数, 1表示负数

​			1 ===>> [0000 0001]    -1 ===>> [1000 0001]

​		(2) 正数的原码, 反码, 补码都一样

​		(3) 负数的反码=它的原码符号位不变, 其他位去反( 0 ->1, 1 ->0)

​			1 ===> 原码 [ 0000 000 1]  反码 [0000 000 1] 补码 [0000 000 1]

​			-1 ===> 原码 [ 1000 000 1]  反码 [1111 1110] 补码 [1111 11111]

​		(4) 负数的补码 = 它的反码 + 1

​		(5) 0的反码, 补码都是0

​		(6) 在计算机运算时 都是以补码的方式来运算的

​	











#### 九、键盘输入语句

​	func Scanf

​	`func.Scanf`

##### 	9.1 介绍

​		需要接收用户输入的数据, 就可以使用键盘输入语句来获取

​	**步骤**: (1) 导入fmt包 (2) 调用fmt包 fmt.ScanIn() 或者 fmt.Scanf()

   	

##### 	9.2 案例演示:

​		要求: 可以从控制台接受到用户信息. [ 姓名, 年龄, 薪水, 是否通过考试 ]

​		(1) 使用 fmt.Scanln() 获取

```
	var name string
	var age byte
	var sal float32
	var isPass bool

	fmt.Println("请输入姓名")
	fmt.Scanln(&name)

	fmt.Println("请输入年龄")
	fmt.Scanln(&age)

	fmt.Println("请输入薪水")
	fmt.Scanln(&sal)

	fmt.Println("请输入是否通过考试")
	fmt.Scanln(&isPass)

	fmt.Printf("名字是 %v \n 年龄是 %v \n 薪水是 %v \n 是否通过考试 %v \n", name, age, sal, isPass)
```

​		(2) 使用 fmt.Scanf() 获取

```
	var name string
	var age byte
	var sal float32
	var isPass bool
	
	fmt.Println("请输入你的姓名, 年龄, 薪水, 是否通过考试, 输入时请用空格隔开")
	fmt.Scanf("%s %d %f %t", &name, &age, &sal, &isPass)
	fmt.Printf("名字是 %v \n 年龄是 %v \n 薪水是 %v \n 是否通过考试 %v \n", name, age, sal, 		isPass)
```



#### 十、进制

##### 	10.1 进制介绍

​		对于整数, 有四种表示方式

​		(1) 二进制: 0, 1, 满 2 进 1.

​		(2) 十进制: 0-9, 满 10 进 1.

​		(3) 八进制: 0 - 7, 满 8 进 1. 以数字0开头表示

​		(4) 十六进制: 0 ~ 9 及 A - F, 满 16 进 1 以 0x或者0X开头表示

​			此处的A-F不区分大小写 如: 0 X 21 AF + 1 = 0 X 21B0

##### 	10.2 案例演示

```
var i int = 5
// 二进制输出
	fmt.Printf("%b \n", i) // 101

// 八进制: 0 - 7, 满8进1. 以数字0开头表述
	var j int = 011 // o11 => 9
	fmt.Printf("j=%v \n", j)

// 0 - 9 以及 A - F, 满16进1. 以0x或0X开头表示
	var k int = 0x11 // 0x11 => 16 + 1 = 17
	fmt.Printf("k=%v \n", k)
```

##### 	10.3 进制的图示

| 十进制 | 十六进制 | 八进制 | 二进制 |
| :----: | :------: | :----: | :----: |
|   0    |    0     |   0    |   0    |
|   1    |    1     |   1    |   1    |
|   2    |    2     |   2    |   10   |
|   3    |    3     |   3    |   11   |
|   4    |    4     |   4    |  100   |
|   5    |    5     |   5    |  101   |
|   6    |    6     |   6    |  110   |
|   7    |    7     |   7    |  111   |
|   8    |    8     |   10   |  1000  |

|  9   |  9   |  11  | 1001  |
| :--: | :--: | :--: | :---: |
|  10  |  A   |  12  | 1010  |
|  11  |  B   |  13  | 1011  |
|  12  |  C   |  14  | 1100  |
|  13  |  D   |  15  | 1101  |
|  14  |  E   |  16  | 1110  |
|  15  |  F   |  17  | 1111  |
|  16  |  10  |  20  | 10000 |
|  17  |  11  |  21  | 10001 |



#### 十一、进制的转换

##### 	11.1 (其他进制转十进制)

​		(1) 二进制转十进制

​			**规则** : 从最低位开始(右边的), 将每个位上的数提取出来, 乘以2的(位数 - 1) 次方,然后求和

​			**案例** : 请将 **1011** 转成十进制的数

​				**1011** = 1 * 1 + 1 * 2 + 0 * 2 * 2 + 1 * 2  * 2 * 2 = 11

​		(2) 八进制转十进制

​			**规则** : 从最低位开始 (右边的) , 将每个位上的数提取出来, 乘以8的(位数 - 1) 次方,然后求和

​			**案例** : 请将 **0123** 转成十进制的数

​				**0123** = 3 * 1 + 2 * 8 + 1 * 8 * 8 =83

​		(3) 十六进制转十进制

​			**规则** : 从最低位开始 (右边的) , 将每个位上的数提取出来, 乘以16的(位数 - 1) 次方,然后求和

​			**案例** : 请将 **0x34A** 转成十进制的数

​				**0x34A** = 10 * 1 + 4 * 16 + 3 * 16 * 16 = 842

##### 	11.2 (十进制转成其他进制)

​	(1) 十进制转换成二进制

​		**规则** : 将该数不断除以2, 直到商为0, 然后将每步得到的余数倒过来,就是对应的二进制

​		**案例** : 请将  **56**  转成二进制的数

​		56 = 56 / 2 / 2 / 2 / 2 / 2 / = 111000

​	![十进二](E:\study\GOPROJECTS\笔记\十进二.png)

​	(2) 十进制转换成八进制

​		**规则** : 将该数不断除以8, 直到商为0, 然后将每步得到的余数倒过来,就是对应的八进制

​		**案例** : 请将  **156**  转成八进制的数

   		同上(1)     156 = 0234



​	(3) 十进制转换成十六进制

​		**规则** : 将该数不断除以16, 直到商为0, 然后将每步得到的余数倒过来,就是对应的十六进制

​		**案例** : 请将  **356**  转成八进制的数

​			同上(1)     356 = 0x164

##### 	11.3 二进制 转换成其他进制

​	(1) 二进制转换成八进制

​		**规则** : 将二进制数每三位一组(从低位开始组合), 转成对应的 **八进制** 数即可

​		**案例** : 请将二进制  **11010101**  转成八进制的数

 			11 010 101 =  0325(101 = 5, 010 = 2, 11 = 3)

​	(2) 二进制转换成十六进制

​		**规则** : 将二进制数每四位一组(从低位开始组合), 转成对应的 **十六进制** 数即可

​		**案例** : 请将二进制  **11010101**  转成十六进制的数

​			1101 0101 = 0xD5 (0101 = 5; 1101 = D)





#### 十二、程序流程控制介绍

##### 	12.1 基本介绍

​		在程序中, 程序运行的流程控制决定程序是如何执行的 使我们必须掌握的, 主要有三大流程控制的语句

##### 	12.2 顺序控制

​		程序从上到下逐行执行

##### 	12.3 分支控制 if - else

​		(1) 单分支 同js if ()

```
var age int
fmt.PrintIn("请输入年龄:")
fmt.ScanIn(&age)

if age > 18 {
	fmt.PrintIn("你的年龄大于18", 要对自己的行为负责)
}
```

​		(2) 双分支

```
var age int
fmt.PrintIn("请输入年龄:")
fmt.ScanIn(&age)

if age > 18 {
	fmt.PrintIn("你的年龄大于18, 要对自己的行为负责")
} else {
	fmt.PrintIn("你的年龄不大 这次先放过你")
}
```

​		(3) 多分支同js

```
var age int
fmt.PrintIn("请输入年龄:")
fmt.ScanIn(&age)

if age > 18 {
	fmt.PrintIn("你的年龄大于18, 要对自己的行为负责")
} else if age < 18 {
	fmt.PrintIn("你的年龄不大 这次先放过你")
}
```



##### 	12.4 switch 分支结构

​		基本介绍: switch语句基本不同条件执行不同的动作, 每一个case分支都是唯一的 从上下逐一测试, 知道匹配

​		匹配项后面不需要在家break

```
var key byte
fmt.PrintIn("请输入一个字符 a,b,c,d,e")
fmt.Scanf("%c", &key)

switch key {
	case 'a':
		fmt.PrintIn("周一, 猴子穿新衣")
	case 'b':
		fmt.PrintIn("周二, 猴子穿新衣")
	case 'c':
		fmt.PrintIn("周三, 猴子穿新衣")
	default:
		mt.PrintIn("输入有误.......")
}
```

##### 	12.5 for循环控制

```
for i := 1; i <=10; i++ {
	fmt.PrintIn("你好, 帅哥!")
}
```

##### 	12.6 跳转控制语句 break

​		**案例** : 随机的生成1 - 100的一个数字, 直到生成了99这个数,看看你一共用了几次

​		**分析** : 编写一个无限循环的控制, 然后不停的随机生成数字, 当生成99时 就退出这个无限循环 ===> break

```go
	// 生成随机数, 还需要个rand设置种子
	// time.Now().Unix(): 返回一个从 1970:01:01 的0时0分0秒到现在的秒数
	// rand.Seed(time.Now().Unix())

	// n := rand.Intn(100) + 1 // [0 ~ 100]
	// fmt.Println(n)

	// = 要和var 关键字一起使用。var可以在函数中使用，也可以在函数外使用。
	// := 只能在函数中使用，所以只能定义局部变量。
	//用var定义之后，用=赋值之后，还可以改变。但是用:=定义的变量不能改变值（也就是b:="q",在函数中不能再重新这样定义 b:="s",但是可以b="s"）
	// 3、var和=可以平行定义并赋值：
	var count int = 0
	for {
		rand.Seed(time.Now().Unix())
		n := rand.Intn(100) + 1
		count ++
		if (n == 99) {
			break // 结束循环
		}
	}
	fmt.Println("生成99 一共使用了几次", count)
```



##### 	12.7 跳转控制语句 continue

###### 		12.7.1 基本介绍 :

​			(1) continue语句用于结束本次循环, 继续执行下一次循环

​			(2) continue语句出现在多层嵌套的循环语句中, 可以通过标签指明要跳过的是那一层循环,

###### 		12.7.2 基本语法 :

​			{ .....

 				continue;

​			......}

###### 		12.7.2 基本案例分析和说明 :

```
for i := 0; i < 4; i++ {
	if i == 2 {
		continue // 回自动跳过 i==2 返回给循环
	}
	fmt.PrintIn("j=", j) // 输出 0, 1, 3, 4
}
```



##### 	12.8 跳转控制语句 goto

###### 		12.8.1 基本介绍

​			(1) Go语言的 goto 语句可以无条件的转移到程序中指定的行

​			(2) goto 语句通常与条件语句配合使用. 可以实现条件转移,跳出循环的功能

​			(3) 在Go程序设计中一般不主张使用goto的语句, 以免程序流程混乱



###### 		12.8.2 基本语法:

​			goto label

​			...

​			label: statement



###### 		12.8.3 案例演示

```go
fmt PrintIn("ok1")
goto label1
fmt PrintIn("ok2")  // 跳过
fmt PrintIn("ok3") 	// 跳过
fmt PrintIn("ok4") 	// 跳过
label1:
fmt PrintIn("ok5")
fmt PrintIn("ok6")
 
//输出 ok1, ok5, ok6
```



##### 	12.9 跳转控制语句 return

###### 		12.9.1 介绍

​			return使用在方法或者函数中 表示跳出所在的方法或函数

###### 		12.9.2 案例

```
for i := 1; i <= 10; i++ {
	if i == 3 {
		return
	}
	fmt.PrintIn("哇哇", i)
}
```



#### 十三、函数

##### 	13.1 函数的定义

​		func 函数名 ( 形参列表 ) (返回值类型列表) {

​			执行语句....

​			return 返回值列表

​		}

​		( 1 ) 形参列表 : 表示函数的输入

​		( 2 ) 函数中的语句 : 表示为了实现某一功能代码块

​		( 3 ) 函数可以有返回值, 也可以没有返回



##### 		13.2 包的介绍

###### 			13.2.1 包的基本概念

​				说明 : go的每一个文件都是属于一个包, 也就是说go是以包的形式来管理文件和项目目录结构的

​			先看一个需求

###### 			13.2.2 包的三大作用

​				( 1 ) 区分相同名字的函数, 变量等标识符

​				( 2 ) 控制函数, 变量等访问范围, 即作用域

###### 			13.2.3 包的相关说明

​				打包基本语法	package util

​				引入包的基本语法  import "包的路径"

​			(1) 在实际开发中 往往需要不同的文件中 调用其他的文件定义的函数, 比如: 在main.go中去使用 utils.go 去					使用utils.go文件中的函数, 如何实现?

​			(2) 程序员小明希望定义函数Cal, 程序员小强也希望定义函数Cal 两个人吵起来了 怎么解决?

​		

##### 		13.3 函数-递归调用

###### 			13.3.1 基本介绍

​				一个函数在函数体内又调用了本身, 称为递归调用

###### 			13.3.2 函数的注意事项和细节

​				( 1 ) 函数的形参列表可以使多个, 返回值列表也可以是多个

​				( 2 ) 形参列表和返回值列表的数据类型可以是值类型和应用类型

​				( 3 ) 函数的命名遵循标识符命名规范, 首字母不能是数字, 首字母大写该函数可以被本包文件和其他包文件使用. 类型 public, 首字母小写, 只能被本包文件使用, 其他包文件不能使用, 类似private

​				( 4 ) 函数中的变量是局部的 函数外不生效

​				( 5 ) 基本数据类型和数组默认都是值传递. 即进行值拷贝, 在函数内修改, 不会影响到原来的值

​				( 6 ) 如果希望函数内的变量能修改函数外的变量, 可以传入变量的地址&, 函数内以指针的方式操作变						量

​				( 7 ) Go函数不支持重载



##### 			13.4 init函数

###### 				13.4.1 基本介绍

​					每一个源文件都可以包含一个init函数, 该函数会在main函数执行前, 被Go运行框架调用, 也就是说					init会在main函数前被调用

###### 				13.4.2 细节

​					init函数最主要的作用, 就是完成一些初始化玩的工作



##### 			13.5 匿名函数

###### 				13.5.1 介绍

​					Go支持匿名函数, 如果我们某个函数希望使用一次, 可以使用匿名函数, 匿名函数可以实现多次调用

###### 				13.5.2 匿名函数使用方式1

​					在定义匿名函数时就直接调用

```
// 第一种写法
res := func (n1 int, n2 int) {
	return n1 + n2
}(n1, n2)

// 第二种写法
a := func(n1 int, n2 int) int {
	return n1 - n2
}
res2 := a(10, 30)
fmt.PrintIn("res", res2)

```



###### 				13.5.3 匿名函数使用方式2

​					将匿名函数赋给一个变量(函数变量), 在通过该变量来调用匿名函数

###### 				13.5.4 全局匿名函数

​					如果将匿名函数赋给一个全局变量, 那么匿名函数,就成为一个全局匿名函数, 可以在程序有效



#### 十四、闭包

##### 	14.1 基本介绍

​		闭包就是一个函数和其他相关的引用环境组合的一个整体

##### 	14.2 案例演示

```go
// 累加器
func AddUpper () func (int) int {
	var n int = 10 
	return func (x int) int {
		n = n + x
		return n
	}
    /*
    // 形成一个整体的闭包 每次调用 n 将会在第一次调用返回的值 累计加加
     var n int = 10 
	return func (x int) int {
		n = n + x
		return n
	}
    */

}

func main () {
	f := AddUpper()
	fmt.PrintIn((f(1))) // 11
	fmt.PrintIn((f(2))) // 13
	fmt.PrintIn((f(3))) // 16
}
```

​		(1) 可以理解为闭包是类, 函数时操作, n是字段, 函数和它使用到n构成闭包

​		(2) 当我们反复调用f函数 因为n是初始化一次, 因此每次调用一次就进行累计

 

#### 十五、函数中的-defer

##### 		15.1 为什么需要defer

​		在函数中, 程序员经常需要创建资源(比如: 数据链接, 文件句柄, 锁), 为了在函数执行完毕后,及时的释放资		源,Go的设计者提供defer(延时机制)

##### 		15.2 案例演示

```go
func sum( n1 int, n2 int) int {
    // 当执行到defer时, 暂时不执行, 会将defer后面的语句压入到独立的栈(defer栈)
    // 当函数执行完毕后, 再从defer栈, 按照先入后出的方式出栈, 执行
    
	defer fmt.PrintIn("ok n1=", n1) // defer 3. ok2 n1= 10
    
	defer fmt.PrintIn("ok n1=", n1) // defer 2. ok2 n2= 20
    
    res := n1 + n2 // res = 30
    fmt.PrintIn("ok res=", res) // 1. ok3 res = 30
    return res
}

func main () {
    res := sum(10, 20)
    fmt.PrintIn("res", res) // 4. res= 30
}
```

##### 		15.3 函数参数的传递方式

###### 				(1) 基本介绍

​			值类型参数默认就是值传递. 而引用类型参数默认就是引用传递

​		(2) 两种传递方式

​			1. 值传递

​			2. 引用传递

​				值传递的是值得拷贝, 引用传递的是地址的拷贝, 一般来说地址拷贝的效率高, 因为数据量小. 而值拷贝				决定拷贝的数据大小, 数据越大.效率越低



##### 			15.4 值类型和引用类型

​			( 1 ) 值类型 : 基本数据类型 int 系列, float系列, bool, string, 数组和结构体struct

​			( 2 ) 引用类型: 指针, slice切片, map, 管道chan, interface 等都是引用类型



##### 			15.5 值类型和引用类型的使用特点

​			(1) 值类型 : 变量直接存储值, 内存通常在栈中分配

​				`var num = 100    内存中 ====> num -----> 100`

​			(2) 引用类型 : 变量存储的是一个地址, 这个地址对应的空间才是真正的存储数据(值), 内存通常在堆上分					配,	当没有任何变量引用这个地址时,该地址对应的数据空间就成为一个垃圾 由GC来回收

​				`引用类型 : 比如 ref    内存中   ref ---> 地址 -----> 值`



#### 十六、变量的作用域

##### 	16.1 说明

​		( 1 ) 函数内部声明/定义的变量叫局部变量, 作用域仅限于函数内部

​		( 2 ) 函数外部声明/定义的变量叫全部变量, 作用域在整个包都有效, 如果首字母为大写, 作用域在整个程序		有效

​		( 3 ) 如果变量在是在一个代码块,比如for/if 那么这个变量的作用域就在该代码块



#### 十七、字符串中的常用的函数

​	( 1 ) 统计字符串的长度, 按字节len(str)

​	( 2 ) 字符串遍历, 同时处理有中文的问题 r := []rune(str)

​	( 3 ) 字符串转整数:       n,err := strconv.Atoi("12")

​	( 4 ) 整数转字符串  str = strconv.ltoa(12345)

​	( 5 ) 字符串转 []byte: var bytes = []byte("hello go")

​	( 6 ) []byte 转 字符串 :str = string([]byte{97, 98, 99})

​	( 7 ) 10进制转2, 8, 16进制: str = strconv,FormatInt(123, 2) // 2 -> 8, 16

​	( 8 ) 查找子串是否在指定的字符串中: strings.Contains("seafood", "foo") // true

​	( 9 ) 统计一个字符串有几个指定的子串: strings.Count("ceheese", "e") // 4

​	( 10 ) 不区分大小写的字符串比较(==是区分字母大小写的): fmt.PrintIn(string.EqualFold("abc", "abc")) // 	true

​	( 11 ) 返回子串在字符串第一次出现的index值, 如果没有返回 -1  :strings.Index("NLT_abc", abc) //4

​	( 12 ) 返回子串在字符串最后一次出现的index, 如没有返回 -1: strings.LastIndex("go golang", "go")

​	( 13 ) 将指定的子串替换成另外一个子串: string.Replace("go go hello", "go". "go", "go语言", n) n可以指定你希望替换的几个, 如果n = -1 表示全部替换

​	( 14 ) 按照指定的某个字符, 为分割标识. 将一个字符串拆分成字符串数组:  strings.Split("hello, wrold", ".")

​	( 15 ) 将字符串的字母进行大小写的转换: strings.ToLower("Go") // go strings.ToUpper("Go") // Go

​	( 16 ) 将字符串左右两边的空格去掉: string.TrimSpace(" tn a lone gopher ntrn")

​	( 17 ) 将字符串左右两边指定的字符去掉: strings.Trim(" ! hello!", "!") // ["hello"] // 将左右两边 ! 和 "" 去掉

​	( 18 ) 将字符串左边指定的字符全掉: strings.TrimLeft( "! hello", "!") // ["hello"] // 将左边 ! 和 "" 去掉

​	( 19 ) 将字符串右边到指定的字符去掉:  strings.TrimRight(" ! hello!", " ! ") //  [ "hello" ] // 将右边 ! 和 "" 去掉



#### 十八、时间和日期相关函数

##### 		1. 时间和日期相关函数, 需要导入time包

​		( 1 ) time.Time类型, 用于表示时间

​			`now := time.Now()`

​		( 2 ) 获取到当前时间的方法:

​			`now := time.Now()` // now的类型就是time.Time

​		( 3 ) 如何获取到其他的日期信息

​			`fmt.PrintIn("当前年=", now.Year())`

​			`fmt.PrintIn("当前月=", time.Now().Month())`

​			// 可以将返回的Month转成对应的数值

​			`fmt.PrintIn("当前月=", int(time.Now().Month()))`

​			`fmt.PrintIn("当前日=", tiem.Now().Day())`

​			`fmt.PrintIn("当前时=", tiem.Now().Hour())`

​			`fmt.PrintIn("当前分=",tiem.Now().Minute())`

​			`fmt.PrintIn("当前秒=", tiem.Now().Second())`

​		( 4 ) 时间的常量

​			const (

​				Nanosecond Duration = 1 // 纳秒

​				Microsecond = 1000 * Nanosecond // 毫秒

​				Millisecond = 1000 * Microsecond // 秒

​				Minute = 60 * Second // 分

​				Hour= 60 * Minute // 小时

​			)

​			**常量的作用** : 在程序中可用于获取指定时间单位的时间, 比如得到100毫秒

​				100 * time.Millisecond

​		( 5 ) 休眠

​			func Sleep( d Duration )

​			案例 : time.Sleep( 100 * time.Millisecond) // 休眠100毫秒



#### 十九、内置函数

##### 	19.1 说明

​		go设计者为了编程方便, 提供了一些函数, 这些函数可以直接使用, 我们称之为Go的内置函数

​		文档 : https://studygolang.com/pkgdoc --> builtin

##### 	19.2 len

​		len用来求长度, 比如 string, array, slice, map, channel

##### 	19.3 new

​		用来分配内存, 主要用来分配值类型, 比如 int, float32, struct......返回的是指针

##### 	19.4 make

​		用来分配内存, 主要分配引用类型吗比如 chan, map, slice



#### 二十、错误处理

##### 		20.1 错误说明

​		( 1 ) go语言的追求简洁优雅, 所以Go语言不支持传统得到 try... catch... finally 这种处理

​		( 2 ) Go引入的处理方式为 :defer, panic, recover

​		( 3 ) Go可以抛出一个panic的异常, 然后在defer中通过recover捕获这个异常, 然后正常处理

```go
package main
import(
	"fmt"
)
func test () {
	num1 := 10
	num2 := 0
	res := num1/num2
	fmt.PrintIn("res", res) // 报错
}

func main () {
	test ()
	fmt.PrintIn("下面的代码和逻辑")
}

// 引出golang的错误处理机制
```

​	当前程序错误处理:

​		( 1 )  在默认情况下 当发生错误后(panic), 程序就会退出

​		( 2 ) 如果我们希望.当发生错误后, 可以捕获到错误, 并进行处理, 保证程序可以继续执行. 还可以在捕获到错		误	后,给管理员代码提示(邮件, 短信)

##### 	20.2 使用 defer + recover来处理错误

```
package main
import(
	"fmt"
)
func test () {
	// 使用 defer + recover 来捕获和处理异常
	defer func() {
		err := recover() // recover内置函数, 可以捕获到异常
		if err != nil { // 说明捕获到错误
			fmt.PrintIn("err", err)
		}
	}
	num1 := 10 
	num2 := 0
	res := num1/num2
	fmt.PrintIn("res", res) // 报错
}

func main () {
	test ()
	fmt.PrintIn("下面的代码和逻辑") 
}
```

##### 	20.3 错误处理的好处

​		进行错误处理后, 程序不会轻易挂掉, 如果加入预警的代码, 就可以让程序更加的健壮.

##### 	20.4 自定义错误

​		在go程序中, 支持自定义错误, 使用errors,New 和 panic内置函数

​		( 1 ) errors.New("错误说明"), 会返回一个error类型的值, 表示一个错误

​		( 2 ) panic内置函数, 接受一个interface{}类型的值(也就是任何值)作为参数, 可以接受error

​		类型的变量, 输出错误信息, 并退出程序

###### 		案例演示

```
// 函数读取配置文件init.conf的信息
// 如果传入文件名不正确,我们就返回一个自定义错误
func readConf(name string) (err error) {
	if name == "config,ini" {
		// 读取
		return nil
	} else {
		// 返回一个自定义错误
		return errors.New("读取文件错误...")
	}
}

func test () {
	err := readConf("config.ini")
	if err != nil {
		// 如果读取文件发送错误, 就输出这个错误 并终止程序
		panic(err)
	}
	fmt,PrintIn("test() 继续执行....")
}
```



#### 二十一、数组和切片

##### 	21.1 数组介绍

​		数组可以存放多个同一类型数据, 数组也是一种数据类型 在Go中 数组是值类型

##### 	21.2 数组定义

​		`var 数组名 [数组大小]数据类型`

​		`var a [5]int`

​		`赋值 a[0] = 1 a[1] = 30`

##### 	21.2 数组内存

```go
var  intArr [3]int
// 定义完数组后, 其实数组的哥哥元素有默认值 0
fmt.PrintIn(intArr)

// 内存空间 intArr值类型
10 | 20 | 30

10 内存地址是 0xc04204a0a0
20 内存地址是 0xc04204a0a8
30 内存地址是 0xc04204a0b0

```

​		总结: 

​			( 1 ) 数组的地址可以通过数组名来获取 &intArr

​			( 2 ) 数组的第一个元素的地址, 就是素组的首地址

​			( 3 ) 数组的各个元素的地址间隔是依据数组的类型决定的 比如 int64 -> 8 int32 ->4 字节

##### 	21.3 数组使用初始化方式

```go
var numsArray [3]int = [3]int {1, 2, 3}
var numsArray  = [3]int {1, 2, 3}
var numsArray = [...]int {1, 2, 3}
// 还可以指定元素值对应的下标
var names = [3]string{ 1: "tom", 0: "jack", 2: "marry"}
```

##### 	21.4 数组的遍历

​		( 1 ) 常规遍历 for

​		( 2 ) for-range结构遍历

​			Go语言独有的结构, 可以遍历访问数组的元素

​			**基本语法 :**

​			for index, value := range array01 {......}

​			**说明 :**

​			第一个返回值index是数组的下标

​			第二个value是在该下标位置的值

​			他们都是仅在for循环内部可见的局部变量

​			遍历数组元素的时候,如果不想使用下标index, 可以直接把下标index标为下划线_

​			index和value的名称不是固定的 即程序员可以自行指定, 一般命名为index和value

###### 		21.4.1 数组使用的注意事项和细节

​			( 1 ) 数组是多个相同的类型数据组合, 一旦声明/定义 长度是固定的,不能动态变化

​			( 2 ) var arr []int 这时 arr 就是一个slice 切片

​			( 3 ) 数组中的元素可以是任何数据类型的, 包括值类型和引用类型 但不能混用

​			( 4 ) 数组创建后, 如果没有赋值, 有默认值(零值)

​					数组类型数组: 默认值为 0

​					字符串数组: 默认值为 ""

​					bool数组:  默认值为fasle

​			( 5 ) 使用数组的步骤: 1. 声明数组并开辟空间 2. 给数组各个元素赋值 3. 使用数组

​			( 6 ) 数组的下标是从 0 开始的

​			( 7 ) 数组下标必须是在指定的范围内使用, 否则报panic, 数组越界

​					比如 var arr [5]int 则有效的下标为0-4

​			( 8 ) Go的数组属于值类型. 在默认情况下是值传递. 因此会进行值拷贝. 数组间不会互相影响

​			( 9 ) 如果想在其他函数中, 去修改原来的数组, 可以使用引用传递(指针方式)

##### 	21.5 数组复杂使用-数组反转

​		**要求 :** 随机生成五个数, 并将其反转打印

​		

##### 	21.6 切片

###### 			21.6.1 切边的基本介绍

​		( 1 ) 切片的英文是slice

​		( 2 ) 切片是数组的一个引用, 因此切片是引用类型,在进行传递时, 遵守引用传递的机制

​		( 3 ) 切片的使用和数组类似, 遍历切片, 访问切片的元素和求切片的长度len( slice )都一样

​		( 4 ) 切片的长度是可以变化的 因此切片是一个可以动态变化数组

​		( 5 ) 切片定义的基本语法 :

​			var 变量名 []类型  比如 : var a []int

###### 			21.6.2代码演示

```go
// 演示切片的基本使用
var intArr [5]int = [...]int{1, 2, 33, 66, 99}
// 声明/定义切片  slice := intArr[ 1:3 ]
// 1. slice 切片名 2. intArr[1:3] 表示 slice 引用到intArr数组
// 2. 引用 intArr 数组的起始下标为 1. 最后的下标为3
// 3. 引用intArr数组的起始下标为 1.最后的下标为 3(但不包含3)
slice := intArr[1:3]
fmt.PrintIn("intArr=", intArr)
fmt.PrintIn("slice 的元素是=", slice) 22. 23
fmt.PrintIn("slice 的元素个数=", len(slice)) 2
fmt.PrintIn("slice 的容量 =", cap(slice))

```

###### 	21.6.3 切片在内存中形式

​		为了让大家更加深入的理解切片, 切片在内存中如何布局的( 重要 )

​		( 1 ) 切片的底层的数据结构可以理解成一个结构体 struct

​		( 2 ) 输出切片和切片引用的地址

###### 		21.6.4 切片的使用

​			方式一

```
// 演示切片的基本使用
var intArr [5]int = [...]int{1, 2, 33, 66, 99}
// 声明/定义切片  slice := intArr[ 1:3 ]
// 1. slice 切片名 2. intArr[1:3] 表示 slice 引用到intArr数组
// 2. 引用 intArr 数组的起始下标为 1. 最后的下标为3
// 3. 引用intArr数组的起始下标为 1.最后的下标为 3(但不包含3)
slice := intArr[1:3]
fmt.PrintIn("intArr=", intArr)
fmt.PrintIn("slice 的元素是=", slice) 22. 23
fmt.PrintIn("slice 的元素个数=", len(slice)) 2
fmt.PrintIn("slice 的容量 =", cap(slice))
```

​			方式二

```go
// 通过make来创建切片
// 基本语法 : var 切片名 []type = make([], len, [cap])
// 参数说明: 
	type: 就是数据类型
	len: 大小
	cap 指定切片的容量

var slice []int = make([]int, 4)
fmt.PrintIn(slice) // 默认值为0
slice[0] = 100
slice[2] = 200
fmt.PrintIn(slice)

```

​		方式一 和 方式二 的区别

​			方式一  是直接引用数组, 这个数组事先存在, 程序是可见的

​			方式二  是通过make来创建切片, make会创建一个数组, 是由切片在底层进行维护的 程序是看不见的

​		

###### 	21.6.5 切片的遍历

​		切片的遍历和数组一样, 也有两种方式

​		( 1 ) for 循环常规方式的遍历

​			同数组一样的

​		( 2 ) for-range 结构遍历切片

​			同数组一样的

​		**切片注意事项和细节**

​		( 1 ) 切片的初始化时

​			var slice = arr[ startIndex : endIndex ]

​			说明: 从arr数组下标为 startIndex, 取到 下标为 endIndex 的元素( 不含 arr[endIndex])

​		( 2 ) 切片初始化时 任然不能越界, 范围在 [ 0-len(arr)]之间, 但是可以动态增长

​		 ( 3 ) var slice = arr[ 0 : end ] 可以简写  var slice = arr[:end]

​		( 4 ) var slice = arr[ start : len(arr) ] 可以简写  var slice = arr[ start:]

​		( 5 ) var slice = arr[ 0 : len(arr) ] 可以简写  var slice = arr[ : ]

​		( 6 ) cap 是一个内置函数, 用于统计切片的容量, 即最大可以存放多少个元素

​		( 7 ) 切片定义完成后, 还不能使用, 因为本身是一个空的, 需要引用到一个数组,或者make一个空间供切片来				使用

​		( 8 ) 切片可以继续切片

​		**用append内置函数, 可以对切片进行动态追加**

```go
var arr [5]int = [5]int { 1, 2, 3, 4, 5 }

var slice = arr[i]

// 追加具体的元素
slice = append( slice, 10, 20, 30)
fmt.PrintIn("slice", slice)

// 在切片上追加切片
var a = []int{ 100, 200 }
slice = append{ slice, a...}
fmt.PrintIn("slice", slice)
```

​	切片append 操作的底层原理分析:

​	( 1 ) 切片 append 操作的本质就是怼数组扩容

​	( 2 ) go底层会创建一下新的数组newArr( 安装扩容后大小 )

​	( 3 ) 将 slice 原来包含的元素拷贝到新的数组newArr

​	( 4 ) slice 重新应用到 newArr

​	( 5 ) 注意newArr 是在底层来维护的, 程序不可见

​	( 6 ) 案例演示